;;;; knot-a-joke.lisp

(in-package #:knot-a-joke)

(cl-interpol:enable-interpol-syntax)

;;; "knot-a-joke" goes here. Hacks and glory await!

;; OK, now I have s-exp representation graph.
;; What I really want is to:
;;   * extract singlet, doublet, triplet, etc subgraphs.
;;   * for a given node, extract its path-subgraph

(defun direct-hashes (s-exp-graph)
  (let ((res (make-hash-table :test #'equal)))
    (iter (for (nil num edges) in s-exp-graph)
	  (setf (gethash num res)
		(let ((sub-res (make-hash-table :test #'equal)))
		  (iter (for (src-part . dst-parts) in edges)
			(setf (gethash src-part sub-res) dst-parts))
		  sub-res)))
    ;; we add an empty partition (to make all subsequent algorithms more comfortable)
    (when (and (not (gethash 0 res))
	       (equal 1 (hash-table-count (gethash 1 res))))
      (setf (gethash 0 res)
	    (let ((it (make-hash-table :test #'equal)))
	      (iter (for (key nil) in-hashtable (gethash 1 res))
		    (setf (gethash '() it) `((,key 1))))
	      it)))
    res))

(defun reverse-hashes (direct-hashes)
  (let ((res (make-hash-table :test #'equal)))
    (iter (for (num edges) in-hashtable direct-hashes)
	  ;; (format t "~a ~a~%" num edges)
	  (let ((sub-res (or (gethash (1+ num) res)
			     (setf (gethash (1+ num) res)
				   (make-hash-table :test #'equal)))))
	    (iter (for (src dests) in-hashtable edges)
		  (iter (for (dest multiplicity) in dests)
			(push (list src multiplicity)
			      (gethash dest sub-res))))))
    res))

(defun hash->assoc (hash)
  (iter (for (key val) in-hashtable hash)
	(collect (cons key val))))

(defun find-partition (reverse-hashes partition &optional layer)
  (if layer
      (or (gethash partition (gethash layer reverse-hashes))
	  (error "Partition ~a is not found in layer ~a" partition layer))
      (let ((sum (apply #'+ partition)))
	(block find-layer
	  (iter (for (key val) in-hashtable reverse-hashes)
		(iter (for (key1 val1) in-hashtable val)
		      (if (not (equal sum (apply #'+ key1)))
			  (terminate))
		      (if (equal partition key1)
			  (return-from find-layer key))))
	  (error "Partition ~a is not found on any of the layers" partition)))))
			  

(defun backpropagate-subgraph (reverse-hashes partition)
  (let ((res (make-hash-table :test #'equal))
	(reverse-hashes reverse-hashes))
    (declare (special res reverse-hashes))
    (let ((layer (find-partition reverse-hashes partition)))
      (declare (special layer))
      (when (not (gethash layer res))
	(setf (gethash layer res)
	      (make-hash-table :test #'equal)))
      (backpropagate-subgraph-elt partition))
    res))

(defun backpropagate-subgraph-elt (partition)
  (declare (special res layer reverse-hashes))
  (if (not (null partition))
      (let ((partition-edges (find-partition reverse-hashes partition layer)))
	(setf (gethash partition (gethash layer res))
	      partition-edges)
	(let ((layer (1- layer)))
	  (declare (special layer))
	  (when (and (not (zerop layer))
		     (not (gethash layer res)))
	    (setf (gethash layer res)
		  (make-hash-table :test #'equal)))
	  (iter (for (edge-src mult) in partition-edges)
		(backpropagate-subgraph-elt edge-src))))))

(defun certified-vertex-p (vertex layer)
  (declare (special layer res))
  (multiple-value-bind (it got) (gethash vertex (gethash layer res))
    (declare (ignore it))
    got))

(defmacro if-debug (&rest forms)
  (declare (ignore forms))
  nil)

;; (defmacro if-debug (&rest forms)
;;   `(format t ,@forms))

(defun extract-n-plet-subgraph-elt ()
  (declare (special direct-hashes n res layer upto-layer))
  (when (and upto-layer (> layer upto-layer))
    (return-from extract-n-plet-subgraph-elt nil))
  (if-debug "Considering layer: ~a~%" layer)
  (let ((hash--2 (gethash (- layer 2) direct-hashes))
	(hash--1 (gethash (- layer 1) direct-hashes)))
    (if (and hash--2 hash--1)
	(let ((res-hash--2 (gethash (- layer 2) res))
	      (res-hash--1 (gethash (- layer 1) res))
	      (banned-vertices (make-hash-table :test #'equal))
	      (vertex-pair-multiplicities (make-hash-table :test #'equal))
	      (vertex-incoming-paths (make-hash-table :test #'equal)))
	  (iter (for (vert nil) in-hashtable res-hash--2)
		;; we really need to go over all edges here -- not just correct n-plet ones
		(let ((edges (gethash vert hash--2)))
		  (if-debug "Considering n-2 vertex: ~a~%" vert)
		  (iter (for (vert1 mult1) in edges)
			(if-debug "  considering n-1 vertex: ~a~%" vert1)
			(let ((certified-p (multiple-value-bind (it got) (gethash vert1 res-hash--1)
					     (declare (ignore it))
					     got)))
			  (iter (for (vert2 mult2) in (gethash vert1 hash--1))
				(if-debug "    considering n vertex: ~a ~a ~a~%" vert2 mult1 mult2)
				(if (gethash vert2 banned-vertices)
				    (next-iteration))
				(when (not (gethash vert2 vertex-incoming-paths))
				  (setf (gethash vert2 vertex-incoming-paths)
					(make-hash-table :test #'equal)))
				(if (not certified-p)
				    (setf (gethash vert2 banned-vertices) t)
				    (progn (setf (gethash (list vert vert2) vertex-pair-multiplicities)
						 (+ (* mult1 mult2)
						    (or (gethash (list vert vert2) vertex-pair-multiplicities)
							0)))
					   (setf (gethash vert1
							  (gethash vert2 vertex-incoming-paths))
						 mult2))))))))
	  (if-debug "Preliminary marking done -- searching for n-plets now~%")
	  (iter (for (vert2 paths) in-hashtable vertex-incoming-paths)
		(if-debug "considering vertex ~a~%" vert2)
		(when (gethash vert2 banned-vertices)
		  (if-debug "  it's banned~%")
		  (next-iteration))
		(when (iter (for (vert nil) in-hashtable res-hash--2)
			    (let ((it (gethash (list vert vert2) vertex-pair-multiplicities)))
			      (if (and it
				       (< n it))
				  (return nil)))
			    (finally (return t)))
		  (if-debug "  it's correctly n-pletic~%")
		  (if (not (gethash layer res))
		      (setf (gethash layer res) (make-hash-table :test #'equal)))
		  (setf (gethash vert2 (gethash layer res)) nil)
		  ;; (if-debug "  vertex incoming paths: ~a~%" (gethash vert2 vertex-incoming-paths))
		  (iter (for (vert1 mult) in-hashtable paths)
			(push (list vert2 mult) (gethash vert1 res-hash--1)))))
	  (when (gethash layer res)
	    (let ((layer (1+ layer)))
	      (declare (special layer))
	      (extract-n-plet-subgraph-elt)))))))

(defun extract-n-plet-subgraph (direct-hashes n &optional upto-layer)
  (let ((res (make-hash-table :test #'equal))
	(direct-hashes direct-hashes)
	(n n))
    (declare (special res direct-hashes n))
    (setf (gethash 0 res) (gethash 0 direct-hashes))
    (iter (for (key val) in-hashtable (gethash 0 direct-hashes)))
    (setf (gethash 1 res)
	  (let ((it (make-hash-table :test #'equal)))
	    (iter (for (key nil) in-hashtable (gethash 1 direct-hashes))
		  ;; so far we don't add any edges -- we add them only later,
		  ;; when we know the vertices they lead to are good
		  (setf (gethash key it) nil))
	    it))
    (let ((layer 2)
	  (upto-layer upto-layer))
      (declare (special layer upto-layer))
      (extract-n-plet-subgraph-elt))
    res))

(defparameter *a* nil)
(defparameter *b* nil)
(defparameter *c* nil)
(defparameter *d* nil)
(defparameter *e* nil)

(defun load-the-graph (&optional (partition "2"))
  (setf *a* (parse-rg-file #?"~/quicklisp/local-projects/knot-a-joke/rep-graph-$(partition).txt"))
  (setf *b* (direct-hashes *a*))
  (setf *c* (reverse-hashes *b*)))

(defun list< (a b)
  (cond ((null a) (not (null b)))
	((null b) nil)
	((= (first a) (first b)) (list< (rest a) (rest b)))
	(t (< (first a) (first b)))))

(defun s-exps (direct-hashes)
  (iter (for (layer specs) in-hashtable direct-hashes)
	(collect (list :layer layer
		       (hash->assoc specs)))))
			     
