;;;; knot-a-joke.lisp

(in-package #:knot-a-joke)

;;; "knot-a-joke" goes here. Hacks and glory await!

;; OK, now I have s-exp representation graph.
;; What I really want is to:
;;   * extract singlet, doublet, triplet, etc subgraphs.
;;   * for a given node, extract its path-subgraph

(defun direct-hashes (s-exp-graph)
  (let ((res (make-hash-table :test #'equal)))
    (iter (for (nil num edges) in s-exp-graph)
	  (setf (gethash num res)
		(let ((sub-res (make-hash-table :test #'equal)))
		  (iter (for (src-part . dst-parts) in edges)
			(setf (gethash src-part sub-res) dst-parts))
		  sub-res)))
    ;; we add an empty partition (to make all subsequent algorithms more comfortable)
    (when (and (not (gethash 0 res))
	       (equal 1 (hash-table-count (gethash 1 res))))
      (setf (gethash 0 res)
	    (let ((it (make-hash-table :test #'equal)))
	      (iter (for (key nil) in-hashtable (gethash 1 res))
		    (setf (gethash '() it) `((,key 1))))
	      it)))
    res))

(defun reverse-hashes (direct-hashes)
  (let ((res (make-hash-table :test #'equal)))
    (iter (for (num edges) in-hashtable direct-hashes)
	  ;; (format t "~a ~a~%" num edges)
	  (let ((sub-res (or (gethash (1+ num) res)
			     (setf (gethash (1+ num) res)
				   (make-hash-table :test #'equal)))))
	    (iter (for (src dests) in-hashtable edges)
		  (iter (for (dest multiplicity) in dests)
			(push (list src multiplicity)
			      (gethash dest sub-res))))))
    res))

(defun hash->assoc (hash)
  (iter (for (key val) in-hashtable hash)
	(collect (cons key val))))

(defun find-partition (reverse-hashes partition &optional layer)
  (if layer
      (or (gethash partition (gethash layer reverse-hashes))
	  (error "Partition ~a is not found in layer ~a" partition layer))
      (let ((sum (apply #'+ partition)))
	(block find-layer
	  (iter (for (key val) in-hashtable reverse-hashes)
		(iter (for (key1 val1) in-hashtable val)
		      (if (not (equal sum (apply #'+ key1)))
			  (terminate))
		      (if (equal partition key1)
			  (return-from find-layer key))))
	  (error "Partition ~a is not found on any of the layers" partition)))))
			  

(defun backpropagate-subgraph (reverse-hashes partition)
  (let ((res (make-hash-table :test #'equal))
	(reverse-hashes reverse-hashes))
    (declare (special res reverse-hashes))
    (let ((layer (find-partition reverse-hashes partition)))
      (declare (special layer))
      (when (not (gethash layer res))
	(setf (gethash layer res)
	      (make-hash-table :test #'equal)))
      (backpropagate-subgraph-elt partition))
    res))

(defun backpropagate-subgraph-elt (partition)
  (declare (special res layer reverse-hashes))
  (if (not (null partition))
      (let ((partition-edges (find-partition reverse-hashes partition layer)))
	(setf (gethash partition (gethash layer res))
	      partition-edges)
	(let ((layer (1- layer)))
	  (declare (special layer))
	  (when (and (not (zerop layer))
		     (not (gethash layer res)))
	    (setf (gethash layer res)
		  (make-hash-table :test #'equal)))
	  (iter (for (edge-src mult) in partition-edges)
		(backpropagate-subgraph-elt edge-src))))))

(defun certified-vertex-p (vertex layer)
  (declare (special layer res))
  (multiple-value-bind (it got) (gethash vertex (gethash layer res))
    (declare (ignore it))
    got))

(defun extract-n-plet-subgraph-elt ()
  (declare (special direct-hashes n res layer))
  (format t "Considering layer: ~a~%" layer)
  (let ((banned-vertices (make-hash-table :test #'equal))
	(all-curlevel-vertices (make-hash-table :test #'equal))
	(vertex-pair-multiplicities (make-hash-table :test #'equal))
	(vertex-incoming-paths (make-hash-table :test #'equal)))
    (iter (for (vert edges) in-hashtable (gethash (- layer 2) res))
	  (format t "Considering n-2 vertex: ~a~%" vert)
	  (iter (for (vert1 mult1) in edges)
		(format t "  considering n-1 vertex: ~a~%" vert1)
		(iter (for (vert2 mult2) in (gethash vert1 (gethash (1- layer) direct-hashes)))
		      (format t "  considering n vertex: ~a ~a ~a~%" vert2 mult1 mult2)
		      (if (gethash vert2 banned-vertices)
			  (next-iteration))
		      (setf (gethash vert2 all-curlevel-vertices) t)
		      (if (not (certified-vertex-p vert1 (1- layer)))
			  (setf (gethash vert2 banned-vertices) t)
			  (progn (setf (gethash (list vert vert2) vertex-pair-multiplicities)
				       (+ (* mult1 mult2)
					  (or (gethash (list vert vert2) vertex-pair-multiplicities)
					      0)))
				 (push (list vert1 mult2)
				       (gethash vert2 vertex-incoming-paths)))))))
    (format t "Preliminary marking done -- searching for n-plets now~%")
    (iter (for (vert2 nil) in-hashtable all-curlevel-vertices)
	  (format t "considering vertex ~a~%" vert2)
	  (when (gethash vert2 banned-vertices)
	    (format t "  it's banned~%")
	    (next-iteration))
	  (when (iter (for (vert nil) in (gethash (- layer 2) res))
		      (let ((it (gethash (list vert vert2) vertex-pair-multiplicities)))
			(if (and it
				 (< n it))
			    (return nil)))
		      (finally (return t)))
	    (format t "  it's correctly n-pletic~%")
	    (if (not (gethash layer res))
		(setf (gethash layer res) (make-hash-table :test #'equal)))
	    (setf (gethash vert2 (gethash layer res)) nil)
	    (iter (for (vert1 mult) in (gethash vert2 vertex-incoming-paths))
		  (push (list vert2 mult) (gethash vert1 (gethash (1- layer) res))))))
    (when (gethash layer res)
      (let ((layer (1+ layer)))
	(declare (special layer))
	(extract-n-plet-subgraph-elt)))))

(defun extract-n-plet-subgraph (direct-hashes n)
  (let ((res (make-hash-table :test #'equal))
	(direct-hashes direct-hashes)
	(n n))
    (declare (special res direct-hashes n))
    (setf (gethash 0 res) (gethash 0 direct-hashes))
    (iter (for (key val) in-hashtable (gethash 0 direct-hashes)))
    (setf (gethash 1 res)
	  (let ((it (make-hash-table :test #'equal)))
	    (iter (for (key nil) in-hashtable (gethash 1 direct-hashes))
		  ;; so far we don't add any edges -- we add them only later,
		  ;; when we know the vertices they lead to are good
		  (setf (gethash key it) nil))
	    it))
    (let ((layer 2))
      (declare (special layer))
      (extract-n-plet-subgraph-elt))
    res))
